__author__ = 'vriz'
# !/usr/bin/env python
# -*-coding: utf-8-*-
"""This module takes data for a new node that is about to be inserted to our grid. Creates a copy of our database and
inserts the new node in the appropriate nodes-table. After that, it splits the link, in which we want the new node
to be inserted, in two parts"""

import pyodbc


class Connect:
    """ Connects us to the database """
    def __init__(self, nodes, links):
        """ Connects us to the database and asks for the names of the node=table and link-table """

        self.cnxn = pyodbc.connect('Trusted_Connection=yes', driver='{SQL Server}', server='localhost', database='PracticeCopy1')
        self.nodes = nodes
        self.links = links


class InsertNode:

    def __init__(self, nodes, links, cnxn, new_nodes, new_links, list_1, list_2):
        self.nodes = nodes
        self.links = links
        self.new_nodes = new_nodes
        self.new_links = new_links
        self.cnxn = cnxn
        self.cursor = self.cnxn.cursor()

        # Create a copy of the nodes table
        self.create_nodes_sql_table(self.nodes, self.new_nodes)

        # Create a copy of the links table
        self.create_links_sql_table_(self.links, self.new_links)

        # The id of the node
        self.node_id = list_1[0]

        # The list that holds the information for the insert method
        self.nodes_list = list_1

        # Get the correct FID number for the row that is about to be inserted
        self.fid = self.get_fid(self.new_nodes)

        # The list that holds the information for the split_link method
        self.links_list = list_2

        # Insert the row
        self.insert(self.new_nodes, self.nodes_list)

        # Split the link
        self.split_link(self.new_links, self.links_list)

        # Reset the FID column
        self.fid_reset(self.new_links)

    def create_nodes_sql_table(self, table, new_table):
        """ This method creates an exact copy of a SQL nodes-table
        @Param table is the table that is going to be copied
        @Param new_table is the new table"""

        # First lets create the new table
        self.cursor.execute("CREATE TABLE dbo."+new_table+" (FID int, ID int, VISIBILITY int, CLASS int, JUNCTION int)")
        # Inform the database so that we can see the changes in the management studio
        self.cnxn.commit()
        # Select all the columns
        self.cursor.execute("SELECT * FROM dbo."+table+" ORDER BY FID ASC")
        # Get all the rows of the table
        rows = self.cursor.fetchall()
        # For every row:
        for part in rows:
            # Pass the values to the new table
            self.cursor.execute("INSERT INTO dbo."+new_table+" VALUES("+str(part[0]) + ', '+str(part[1]) + ', '+str(part[2]) + ', '+str(part[3]) + ', '+str(part[4]) +")")
            # Inform the database
            self.cnxn.commit()

    def create_links_sql_table_(self,table, new_table):
        """ This method creates an exact copy of a SQL links-table
        @ Param table is the table that is going to be copied
        @ Param new_table is the new table"""

        # First lets create the new table
        self.cursor.execute("CREATE TABLE dbo."+new_table+" (FID int, LinkID int,FromNodeID int, ToNodeId int, StartCost int, TravCost int, CLASS int);")
        # Inform the database so that we can see the changes in the management studio
        self.cnxn.commit()
        # Select all the columns
        self.cursor.execute("SELECT * FROM dbo."+table+" ORDER BY FID ASC")
        # Get all the rows of the table
        rows = self.cursor.fetchall()
        # For every row:
        for part in rows:
            # Pass the values to the new table
            self.cursor.execute("INSERT INTO dbo."+new_table+" VALUES("+str(part[0]) + ', '+str(part[1]) + ', '+str(part[2]) + ', '+str(part[3]) + ', '+str(part[4]) + ', '+str(part[5]) + ', '+str(part[6])+")")
            # Inform the database
            self.cnxn.commit()

    def get_fid(self, new_table):
        """ This method finds the correct FID number for our row
        we want to insert in the nodes-table
        @ Param new_table is the copy of the nodes-table
        @ Return is the FID number"""

        # Select everything from our table
        self.cursor.execute("SELECT * FROM dbo."+new_table+" ORDER BY FID ASC")
        # Assign the rows
        rows = self.cursor.fetchall()
        # Set a counter to zero
        counter = 0
        # For every row of the table
        for row in rows:
            # Add one to our counter
            counter += 1
        return counter+1

    def insert(self, new_table, data_list):
        """This method inserts the row to our nodes-table
        @ Param new_table is the copy of the nodes table
        @ Param data_list is the list that holds all the
        information for the new node:
        data_list[1] is the Id of the new node
        data_list[2] is the visibility of the new node
        data_list[3] is the class of the new node
        data_list[4] is the junction variable for the new node"""

        self.cursor.execute("INSERT INTO dbo."+new_table+" VALUES("+str(self.fid) + ', '+str(data_list[0]) + ', '+str(data_list[1]) + ', '+str(data_list[2]) + ', '+str(data_list[3]) +")")
        self.cnxn.commit()

    def split_link(self, new_table, data_list):
        """This method takes a links-table and data for a node that is going to be
        inserted in link and splits the link in 2 parts
        @ Param new_table is the copy of the links-table
        @ Param data_list is a list that holds all the required information :
        data_list[0] is the Id of the link we are about to split in two
        data_list[1] is the Id of the first new link we will create
        data_list[2] is the Id of the second new link we will create
        data_list[3] is the start cost for the first new link
        data_list[4] is the start cost for the second new link
        data_list[5] is the traverse cost for the first new link
        data_list[6] is the traverse cost for the second new link
        """
        # Get the row with where the LinID the one we want to split in two
        self.cursor.execute("SELECT * FROM dbo."+new_table+" WHERE LinkID=?", (data_list[0],))
        row = self.cursor.fetchone()
        # FromNodeID for the first link
        from_node_1 = row[2]
        # ToNodeID for the first link
        to_node_1 = self.node_id
        # The class for both of the new links
        link_class = row[6]
        # FromNodeID for the second link
        from_node_2 = self.node_id
        # ToNodeID for the second link
        to_node_2 = row[3]
        # Find the appropriate FID for the new links we are about to insert in our database
        self.cursor.execute("SELECT * FROM dbo."+new_table)
        rows = self.cursor.fetchall()
        counter = 0
        for part in rows:
            counter += 1
        # Insert first link
        self.cursor.execute("INSERT INTO dbo."+new_table+" VALUES("+str(counter+1) + ', '+str(data_list[1]) + ', '+str(from_node_1) + ', '+str(to_node_1) + ', '+str(data_list[3]) + ', '+str(data_list[5]) + ', '+str(link_class)+")")
        # Inform the database
        self.cnxn.commit()
        # Insert second link
        self.cursor.execute("INSERT INTO dbo."+new_table+" VALUES("+str(counter+2) + ', '+str(data_list[2]) + ', '+str(from_node_2) + ', '+str(to_node_2) + ', '+str(data_list[4]) + ', '+str(data_list[6]) + ', '+str(link_class)+")")
        # Inform the database
        self.cnxn.commit()
        # Delete the link we have already split in two
        self.cursor.execute("DELETE FROM dbo."+new_table+" WHERE LinkID=?", (data_list[0],))
        self.cnxn.commit()

    def fid_reset(self, new_table):
        """This method resets the Fid column of a SQL table after we have
        deleted some rows
        @ Param new_table is the copy of the links-table"""

        # Select all the columns and sort them by their FID with ascending order
        self.cursor.execute("SELECT * FROM dbo."+new_table+" ORDER BY FID ASC")
        # Get all the rows of the table
        rows = self.cursor.fetchall()
        # Create an empty list in which we are going to store the FIDs of the remaining links
        fid_list = []
        # Fill the list with the FIDs
        for part in rows:
            fid_list.append(part.FID)
        # Set a counter to 0
        counter = 1
        # For every element in the fid_list:
        for part in fid_list:
            # Reset the FIDs of every link
            self.cursor.execute("UPDATE dbo."+new_table+" SET FID=? WHERE FID=?", (counter, part,))
            self.cnxn.commit()
            counter += 1


def main():
    connection = Connect("NODES", "LINKS")
    # The numbers are for test purposes
    InsertNode(connection.nodes, connection.links, connection.cnxn, "hi", "hi2", [5555, 1, 11, 1], [222, 11, 22, 101, 102, 1011, 1022])

if __name__ == '__main__':
    main()
