__author__ = 'vriz'
# !/usr/bin/env python
#  -*-coding: utf-8-*-
"""This module takes node-centric table and a link-centric table and creates
 an adjacency dictionary"""

# dbo.NODES ---> Columns ( FID ID VISIBILITY CLASS JUNCTION)
# dbo.LINKS ---> Columns ( FID LinkID FromNodeID ToNodeID StartCost TravCost TWOWAY StartCost2 )

import pyodbc
import csv
from prettytable import PrettyTable


class Connect:
    """ Connects us to the database """
    def __init__(self, nodes, links):
        """ Connects us to the database and asks for the names of the node=table and link-table """

        self.cnxn = pyodbc.connect('Trusted_Connection=yes', driver='{SQL Server}', server='localhost', database='PracticeCopy1')
        self.nodes = nodes
        self.links = links


class Conversion:

    def __init__(self, nodes, links, cnxn):
        self.nodes = nodes
        self.links = links
        self.cnxn = cnxn

        # Create a list with the 2 dictionaries that hold the connections of the nodes
        self.list_of_dictionaries = self.create_list_of_dictionaries(self.get_rows_of_table("SELECT * FROM dbo."+self.links))

        # Create the dictionary with the personal information of each node
        self.dictionary_of_personal_data = self.create_dictionary_of_personal_data(self.get_rows_of_table("SELECT * FROM dbo."+self.nodes), self.list_of_dictionaries)

        # The nodes we need to remove
        self.list_of_nodes_to_remove = self.nodes_to_remove(self.dictionary_of_personal_data)

        # Adjust the personal information for the nodes we want to delete
        self.adjust_links(self.list_of_nodes_to_remove)

        # Reset the FID column
        self.update_database(self.get_rows_of_table("SELECT * FROM dbo."+self.links))

        # Remove the unnecessary nodes
        self.adjust_information(self.list_of_nodes_to_remove)
        
        # Create a list with the 2 dictionaries that hold the connections of the nodes taking into consideration the
        # two-way links
        self.fixed_list_of_dictionaries = self.create_fixed_list_of_dictionaries(self.get_rows_of_table("SELECT * FROM dbo."+self.links))

        # Built the adjacency dictionary
        self.Adjacency_Dictionary = self.build_dictionary(self.dictionary_of_personal_data, self.fixed_list_of_dictionaries)

        # Print it in a pretty way
        self.print_dictionary(self.Adjacency_Dictionary)
        """cursor=self.cnxn.cursor()
        cursor.execute("SELECT GEOMETRY.STAsText() FROM dbo.LINKS WHERE FID = 2 ")
        row=cursor.fetchone()
        self.list=row[0]
        self.test = self.string_to_list(self.list)

        cursor_1=self.cnxn.cursor()
        cursor_1.execute("SELECT GEOMETRY.STAsText() FROM dbo.LINKS WHERE FID = 4 ")
        row=cursor_1.fetchone()
        self.list_1=row[0]
        self.test_1 = self.string_to_list(self.list_1)
        self.TEST = self.connect_links(self.test, self.test_1, 1)
        self.FINAL = self.string_to_database(self.TEST)"""

    def string_to_list(self, input_string):
        # Put all the letters in a list
        lst = []
        for letter in input_string:
            lst.append(letter)
        # Remove the unnecessary characters
        for i in range(0, 12):
            lst.pop(0)
        lst = lst[:-1]
        # Reform the String
        string_1 = "".join(lst)
        # Split the string on the spaces and put the parts on a list
        lst_2 = string_1.split()
        # Putting the coordinates in pairs and then in a list (For uniting links)
        # Create the list that we are going to use as a base
        final_list = []
        # Create a temporary list
        temp_list = []
        i = 0
        # For every coordinate in the list
        for coord in lst_2:
            # Append the temporary list with the coordinate
            temp_list.append(coord)
            # If the coordinate is in position 1,3,5,7...
            if i % 2 != 0:
                # Append the final list with the temporary one
                final_list.append(temp_list)
                # And empty the temporary one
                temp_list = []
            i += 1
        return final_list

    def connect_links(self, list_1, list_2, x):

        if x == 1:
            list_1 = list_1[:-1]
            final_list = list_1 + list_2
        elif x == 2:
            list_1 = list_1[:-1]
            list_1.reverse()
            final_list = list_1 + list_2
        else:
            list_2 = list_2[:-1]
            list_2.reverse()
            final_list = list_1 + list_2
        return final_list

    def string_to_database(self, list_1):
        lst_3 = []
        # For every pair or coordinates
        for part in list_1:
            # For every coordinate
            for coord in part:
                # Append the list
                lst_3.append(coord)
                # Form the string
        space=" "
        final_sting = space.join(lst_3)
        return final_sting

    def get_rows_of_table(self, sql_string):
        """ This method gives us the desired rows of an Sql table
        @Param Sql_String is the Sql string
        @Return are the desired rows """
        cursor = self.cnxn.cursor()
        cursor.execute(sql_string)
        rows = cursor.fetchall()
        return rows

    def create_list_of_dictionaries(self, rows):
        """ This method creates 2 dictionaries
        The first dictionary contains the ID of the nodes where we can move to (from the Key node) and the required
        costs to do that.
        The key of the first dictionary will be a node from the FromNodeID column.
        The value of the key for the first dictionary will be a list of numerous 3 element sub-lists:
        FromNodeID--->[[ToNodeID,StartCost,TravCost] , ....repeat....]
        The second dictionary contains the ID of the nodes where we can travel from, towards the Key node.
        The key of the second dictionary will be a node from the ToNodeID column.
        The value of the key for the second dictionary will be a list of nodes:
        ToNodeID--->[FromNodeID , ....repeat....]
        @Param rows is the rows of the LINKS table
        @Return is a list with the dictionaries """

        # Create empty Dictionaries
        temp_dict_0 = {}
        temp_dict_1 = {}
        # For each row of the rows:
        for row in rows:
            # Building the Temp_Dict0:
            # Try to append the list with the values for the key: row[1] = FromNodeID
            try:
                temp_dict_0[row[2]].append([row[3], row[4], row[5]])
            # and if you cannot find it, create the key and assign the first element of the list as value
            except:
                temp_dict_0[row[2]] = [[row[3], row[4], row[5]]]
            # Building the Temp_Dict1:
            # Try to append the list with the values for the key: row[2] = ToNodeID
            try:
                temp_dict_1[row[3]].append(row[2])
            # and if you cannot find it, create the key and assign the first element of the list as value
            except:
                temp_dict_1[row[3]] = [row[2]]
        return [temp_dict_0, temp_dict_1]

    def create_dictionary_of_personal_data(self, rows, lst):
        """ This method creates a dictionary for the Nodes of the dbo.NODES table.
        The keys will be the ID of each node and the value will be a 3 element list
        ID--->[VISIBILITY, CLASS, JUNCTION]
        For the JUNCTION checks if each node connects to more than 2 other nodes
        It also updates the database
        @Param rows is the rows of the NODES table
        @Param lst is a list tha contains 2 dictionaries with the FromNodeIDs and the ToNodeIDs
        @Return is the dictionary """

        # Create an empty Dictionary
        temp_dict = {}
        # For each row of the nodes table
        for row in rows:
            node = row[1]
            to_dict = lst[0]
            from_dict = lst[1]
            # If the node is a key in both of the 2 dictionaries
            if node in from_dict and node in to_dict:
                    # If the FromNodeID nodes = 1 and the ToNodeID nodes = 1
                    if len(from_dict[node]) == 1 and len(to_dict[node]) == 1:
                        # Assign the values to each Key and set Junction = 0
                        # Junction = 0 means that the node connects two links that both have the same direction
                        temp_dict[node] = [row[2], row[3], 0]
                        self.cnxn.cursor().execute("UPDATE dbo.NODES SET JUNCTION=0 WHERE ID=?", (node,))
                        self.cnxn.commit()
                    else:
                        # Assign the values to each Key and set Junction = 1
                        # Junction = 1 means that there more than 2 links coming to and leaving from our node
                        temp_dict[node] = [row[2], row[3], 1]
                        self.cnxn.cursor().execute("UPDATE dbo.NODES SET JUNCTION=1 WHERE ID=?", (node,))
                        self.cnxn.commit()
            # If the node is a key only in the to_dict which means that you can only travel from the key node towards
            # other nodes
            elif node in to_dict:
                    if len(to_dict[node]) == 2:
                        # Assign the values to each Key and set Junction = 20
                        # Junction = 20 means that the node connects two link that both have our node as starting point
                        temp_dict[node] = [row[2], row[3], 20]
                        self.cnxn.cursor().execute("UPDATE dbo.NODES SET JUNCTION=20 WHERE ID=?", (node,))
                        self.cnxn.commit()
                    else:
                        # Assign the values to each Key and set Junction = 2
                        # Junction = 2 means that there are more than 2 links that both have our node as staring point
                        temp_dict[node] = [row[2], row[3], 2]
                        self.cnxn.cursor().execute("UPDATE dbo.NODES SET JUNCTION=2 WHERE ID=?", (node,))
                        self.cnxn.commit()
            # If the node is a key only in the from_dict which means that you can only travel towards the key node from
            #  other nodes
            elif node in from_dict:
                    if len(from_dict[node]) == 2:
                        # Assign the values to each Key and set Junction = 30
                        # Junction = 30 means that the node connects two links that both have our node as ending point
                        temp_dict[node] = [row[2], row[3], 30]
                        self.cnxn.cursor().execute("UPDATE dbo.NODES SET JUNCTION=30 WHERE ID=?", (node,))
                        self.cnxn.commit()
                    else:
                        # Assign the values to each Key and set Junction = 3
                        # Junction = 3 means that there are more than 2 links that both have our node as ending point
                        temp_dict[node] = [row[2], row[3], 3]
                        self.cnxn.cursor().execute("UPDATE dbo.NODES SET JUNCTION=3 WHERE ID=?", (node,))
                        self.cnxn.commit()
            # If the node in not a key in any dictionary which means it has no connections
            else:
                    # Assign the values to each Key and set Junction = 5
                    temp_dict[node] = [row[2], row[3], 5]
                    self.cnxn.cursor().execute("UPDATE dbo.NODES SET JUNCTION=5 WHERE ID=?", (node,))
                    self.cnxn.commit()
        return temp_dict

    def nodes_to_remove(self, dictionary):
        """ This method creates a list with the nodes we want to remove
        @Param dictionary is a dictionary tha holds all the personal information of each node
        @Return is the list with the nodes we want to remove """

        # Create an empty list
        lst_2 = [[], [], []]
        # For each node of the dictionary
        for node, values in dictionary.items():
            # If visibility = 0 and junction = 0
            if values[0] == 1 and values[2] == 0:
                cursor_1 = self.cnxn.cursor()
                cursor_2 = self.cnxn.cursor()
                # Get the link where our node the FromNodeID
                cursor_1.execute("SELECT * FROM dbo.LINKS WHERE FromNodeID=?", (node,))
                row_1 = cursor_1.fetchone()
                # Get the link where our node the ToNodeID
                cursor_2.execute("SELECT * FROM dbo.LINKS WHERE ToNodeID=?", (node,))
                row_2 = cursor_2.fetchone()
                # If both links have the same TWOWAY attribute
                if row_1[7] == row_2[7]:
                    # Append the list
                    lst_2[0].append(node)
            # If visibility = 0 and junction = 20
            elif values[0] == 1 and values[2] == 20:
                cursor_1 = self.cnxn.cursor()
                # Get both links where our node is the FromNodeID
                cursor_1.execute("SELECT * FROM dbo.LINKS WHERE FromNodeID=?", (node,))
                rows_2 = cursor_1.fetchall()
                # Create a temporary list that will hold the TWOWAY attributes for both of our links
                temp_list = []
                for row_2 in rows_2:
                    temp_list.append(row_2[7])
                # If both links are TWOWAY
                if temp_list[0] == 1 and temp_list[1] == 1:
                    # Append the list
                    lst_2[1].append(node)
            # If visibility = 0 and junction = 30
            elif values[0] == 1 and values[2] == 30:
                cursor_1 = self.cnxn.cursor()
                # Get both links where our node is the ToNodeID
                cursor_1.execute("SELECT * FROM dbo.LINKS WHERE ToNodeID=?", (node,))
                rows_3 = cursor_1.fetchall()
                # Create a temporary list that will hold the TWOWAY attributes for both of our links
                temp_list_1 = []
                for row_3 in rows_3:
                    temp_list_1.append(row_3[7])
                # If both links are TWOWAY
                if temp_list_1[0] == 1 and temp_list_1[1] == 1:
                    # Append the list
                    lst_2[2].append(node)
        return lst_2

    def adjust_links(self, list_1):
        """ This method takes a list with 3 sub-lists of nodes we want to delete and adjust the links in the sql table
        @Param list_1 is the list with the sub-lists"""

        # For every node in the first list of nodes we want to delete
        for node in list_1[0]:
            # Create a cursor
            cursor_1 = self.cnxn.cursor()
            # Get the link that has our node as starting point
            cursor_1.execute("SELECT * FROM LINKS WHERE FromNodeID=?", (node,))
            row = cursor_1.fetchone()
            # Set the appropriate values to the variables
            start_cost_2 = row[8]
            trav_cost_2 = row[5]
            end_node_2 = row[3]
            # Close the cursor
            cursor_1.close()

            cursor = self.cnxn.cursor()
            cursor.execute("SELECT GEOMETRY.STAsText() FROM dbo.LINKS WHERE FromNodeID=?", (node), )
            row = cursor.fetchone()
            second = row[0]
            cursor.close()

            # Create a cursor
            cursor_2 = self.cnxn.cursor()
            # Get the link that has our node as ending point
            cursor_2.execute("SELECT * FROM LINKS WHERE ToNodeId=?", (node,))
            row = cursor_2.fetchone()
            # Set the appropriate values to the variables
            trav_cost_1 = row[5]
            # Close the cursor
            cursor_2.close()

            cursor = self.cnxn.cursor()
            cursor.execute("SELECT GEOMETRY.STAsText() FROM dbo.LINKS WHERE ToNodeID=?", (node), )
            row = cursor.fetchone()
            first = row[0]
            cursor.close()

            string_to_database = self.string_to_database(self.connect_links(self.string_to_list(first), self.string_to_list(second), 1))

            # Update the information of the database
            self.cnxn.cursor().execute("UPDATE dbo."+self.links+" SET TravCost=?, StartCost2=? WHERE ToNodeID=?", (trav_cost_1 + trav_cost_2, start_cost_2, node,))
            self.cnxn.commit()
            # Reset the trav_cost
            trav_cost_1 = 0
            #self.cnxn.cursor().execute("UPDATE LINKS SET GEOMETRY=NULL WHERE ToNodeID=?", (node), )
            #self.cnxn.commit()
            self.cnxn.cursor().execute("UPDATE LINKS SET GEOMETRY=geography::STGeomFromText('LINESTRING("+string_to_database+")', 4326) WHERE ToNodeID=?", (node), )
            self.cnxn.commit()
            # Update the information of the database
            self.cnxn.cursor().execute("UPDATE dbo."+self.links+" SET ToNodeID=? WHERE ToNodeID=?", (end_node_2, node,))
            self.cnxn.commit()
            # Delete the unnecessary link
            self.cnxn.cursor().execute("DELETE FROM dbo."+self.links+" WHERE FromNodeID=?", (node,))
            self.cnxn.commit()
        # For every node in the second list of nodes we want to delete
        for node in list_1[1]:
            # Create a cursor
            cursor_1 = self.cnxn.cursor()
            # Select both links where that have our node as starting point
            cursor_1.execute("SELECT * FROM LINKS WHERE FromNodeID=?", (node,))
            rows = cursor_1.fetchall()
            cursor_1.close()
            # Set a counter
            count = 1
            # Save the information of both links in two lists
            for row in rows:
                if count == 1:
                    link_1 = [row[x] for x in range(0, 9)]
                    cursor = self.cnxn.cursor()
                    cursor.execute("SELECT GEOMETRY.STAsText() FROM dbo.LINKS WHERE LinkID=?", (link_1[1]), )
                    row = cursor.fetchone()
                    link_1_geom = row[0]
                    cursor.close()
                if count == 2:
                    link_2 = [row[x] for x in range(0, 9)]
                    cursor = self.cnxn.cursor()
                    cursor.execute("SELECT GEOMETRY.STAsText() FROM dbo.LINKS WHERE LinkID=?", (link_2[1]), )
                    row = cursor.fetchone()
                    link_2_geom = row[0]
                count += 1
            # If the first link's ending node is in third list of nodes we want to delete then we must have the new link
            # pointing towards that node
            if link_1[3] in list_1[2]:
                # Set the appropriate values to the variables
                link_id_to_stay = link_1[1]
                link_id_to_go = link_2[1]
                start_node = link_2[3]
                end_node = link_1[3]
                start_cost_1 = link_2[8]
                start_cost_2 = link_1[8]
                trav_cost_1 = link_1[5]
                trav_cost_2 = link_2[5]
                first = link_2_geom
                second = link_1_geom
                # Create a cursor
                cursor_2 = self.cnxn.cursor()
                # Update the information of the database
                cursor_2.execute("UPDATE dbo."+self.links+" SET ToNodeID=?, StartCost=?, TravCost=?, StartCost2=?, FromNodeID=? WHERE LinkID=?", (end_node, start_cost_1, trav_cost_1 + trav_cost_2, start_cost_2, start_node, link_id_to_stay,))
                cursor_2.commit()
                # Delete the unnecessary link
                cursor_2.execute("DELETE FROM dbo."+self.links+" WHERE LinkID=?", (link_id_to_go,))
                cursor_2.commit()

                string_to_database = self.string_to_database(self.connect_links(self.string_to_list(first), self.string_to_list(second), 2))

                cursor_2.execute("UPDATE LINKS SET GEOMETRY=geography::STGeomFromText('LINESTRING("+string_to_database+")', 4326) WHERE LinkID=?", (link_id_to_stay,), )
                cursor_2.commit()

                # Close the cursor
                cursor_2.close()
            # If the second link's ending node is in third list of nodes we want to delete then we must have the new
            # link pointing towards that node
            elif link_2[3] in list_1[2]:
                # Set the appropriate values to the variables
                link_id_to_stay = link_2[1]
                link_id_to_go = link_1[1]
                start_node = link_1[3]
                end_node = link_2[3]
                start_cost_1 = link_1[8]
                start_cost_2 = link_2[8]
                trav_cost_1 = link_2[5]
                trav_cost_2 = link_1[5]
                first = link_1_geom
                second = link_2_geom
                string_to_database = self.string_to_database(self.connect_links(self.string_to_list(first), self.string_to_list(second), 2))
                # Create a cursor
                cursor_2 = self.cnxn.cursor()
                # Update the information of the database
                cursor_2.execute("UPDATE dbo."+self.links+" SET ToNodeID=?, StartCost=?, TravCost=?, StartCost2=?, FromNodeID=? WHERE LinkID=?", (end_node, start_cost_1, trav_cost_1 + trav_cost_2, start_cost_2, start_node, link_id_to_stay,))
                cursor_2.commit()
                # Delete the unnecessary link
                cursor_2.execute("DELETE FROM dbo."+self.links+" WHERE LinkID=?", (link_id_to_go,))
                cursor_2.commit()
                cursor_2.execute("UPDATE LINKS SET GEOMETRY=geography::STGeomFromText('LINESTRING("+string_to_database+")', 4326) WHERE LinkID=?", (link_id_to_stay,), )
                cursor_2.commit()
                # Close the cursor
                cursor_2.close()
            # If none of the link's ending point is in the third list of nodes we want to delete then we don't have a
            # certain preference for the direction of the new link
            else:
                # Set the appropriate values to the variables
                link_id_to_stay = link_1[1]
                link_id_to_go = link_2[1]
                start_node = link_2[3]
                end_node = link_1[3]
                start_cost_1 = link_2[8]
                start_cost_2 = link_1[8]
                trav_cost_1 = link_1[5]
                trav_cost_2 = link_2[5]
                first = link_1_geom
                second = link_2_geom
                string_to_database = self.string_to_database(self.connect_links(self.string_to_list(first), self.string_to_list(second), 2))
                # Create a cursor
                cursor_2 = self.cnxn.cursor()
                # Update the information of the database
                cursor_2.execute("UPDATE dbo."+self.links+" SET ToNodeID=?, StartCost=?, TravCost=?, StartCost2=?, FromNodeID=? WHERE LinkID=?", (end_node, start_cost_1, trav_cost_1 + trav_cost_2, start_cost_2, start_node, link_id_to_stay,))
                cursor_2.commit()
                # Delete the unnecessary link
                cursor_2.execute("DELETE FROM dbo."+self.links+" WHERE LinkID=?", (link_id_to_go,))
                cursor_2.commit()

                cursor_2.execute("UPDATE LINKS SET GEOMETRY=geography::STGeomFromText('LINESTRING("+string_to_database+")', 4326) WHERE LinkID=?", (link_id_to_stay,), )
                cursor_2.commit()
                # Close the cursor
                cursor_2.close()
        # For every node in the third list of nodes we want to delete
        for node in list_1[2]:
            # Create a cursor
            cursor_1 = self.cnxn.cursor()
            # Get both links that have our node as ending point
            cursor_1.execute("SELECT * FROM LINKS WHERE ToNodeID=?", (node,))
            rows = cursor_1.fetchall()
            count = 1
            # Set the appropriate values to the variables
            for row in rows:
                if count == 1:
                    link_id_to_stay = row[1]
                    start_node = row[2]
                    start_cost_1 = row[4]
                    trav_cost_1 = row[5]
                    cursor = self.cnxn.cursor()
                    cursor.execute("SELECT GEOMETRY.STAsText() FROM dbo.LINKS WHERE LinkID=?", (link_id_to_stay), )
                    row = cursor.fetchone()
                    link_1_geom = row[0]
                    cursor.close()
                if count == 2:
                    link_id_to_go = row[1]
                    end_node = row[2]
                    start_cost_2 = row[4]
                    trav_cost_2 = row[5]
                    cursor = self.cnxn.cursor()
                    cursor.execute("SELECT GEOMETRY.STAsText() FROM dbo.LINKS WHERE LinkID=?", (link_id_to_go), )
                    row = cursor.fetchone()
                    link_1_geom = row[0]
                    cursor.close()
                count += 1
            first = link_1_geom
            second = link_2_geom
            string_to_database = self.string_to_database(self.connect_links(self.string_to_list(first), self.string_to_list(second), 3))
            # Create a cursor
            cursor_2 = self.cnxn.cursor()
            # Update the information of the database
            cursor_2.execute("UPDATE dbo."+self.links+" SET ToNodeID=?, StartCost=?, TravCost=?, StartCost2=?, FromNodeID=? WHERE LinkID=?", ( end_node, start_cost_1, trav_cost_1 + trav_cost_2, start_cost_2, start_node, link_id_to_stay,))
            cursor_2.commit()
            # Delete the unnecessary link
            cursor_2.execute("DELETE FROM dbo."+self.links+" WHERE LinkID=?", (link_id_to_go,))
            cursor_2.commit()

            cursor_2.execute("UPDATE LINKS SET GEOMETRY=geography::STGeomFromText('LINESTRING("+string_to_database+")', 4326) WHERE LinkID=?", (link_id_to_stay,), )
            cursor_2.commit()
            # Close the cursor
            cursor_2.close()

    def update_database(self, rows):
        """This method resets the FID column
        @Param list_0 is the list with the nodes we want to delete"""
        # Set a counter to zero
        counter = 1
        # Get all the rows of the table

        # For each row
        for row in rows:
            # Set the FID equal to the counter variable
            self.cnxn.cursor().execute("UPDATE dbo."+self.links+" SET FID=? WHERE LinkID=?", (counter, row.LinkID))
            self.cnxn.commit()
            counter += 1

    def adjust_information(self, list_1):
        """ This method inserts the correct information for the node after we remove it from a link
        @Param list_1 is the list with the nodes we want to be removed
        @Param dict_1 is the dictionary the holds the personal information for every node
        @Return is a similar dictionary with the correct data"""

        # For every sub list of list_1
        for part in list_1:
            # For every node
            for node in part:
                # Update the database
                self.cnxn.cursor().execute("UPDATE dbo.NODES SET JUNCTION=5 WHERE ID=?", (node,))
                self.cnxn.commit()

    def create_fixed_list_of_dictionaries(self, rows):
        """ This method creates 2 dictionaries
        The first dictionary contains the ID of the nodes where we can move to (from the Key node) and the required
        costs to do that.
        The key of the first dictionary will be a node from the FromNodeID column.
        The value of the key for the first dictionary will be a list of numerous 3 element sub-lists:
        FromNodeID--->[[ToNodeID,StartCost,TravCost] , ....repeat....]
        The second dictionary contains the ID of the nodes where we can travel from, towards the Key node.
        The key of the second dictionary will be a node from the ToNodeID column.
        The value of the key for the second dictionary will be a list of nodes:
        ToNodeID--->[FromNodeID , ....repeat....]
        @Param rows is the rows of the LINKS table
        @Return is a list with the dictionaries """

        # Create empty Dictionaries
        temp_dict_0 = {}
        temp_dict_1 = {}
        # For each row of the rows:
        for row in rows:
            # Building the Temp_Dict0:
            # Try to append the list with the values for the key: row[2] = FromNodeID
            try:
                temp_dict_0[row[2]].append([row[3], row[4], row[5]])
            # and if you cannot find it, create the key and assign the first element of the list as value
            except:
                temp_dict_0[row[2]] = [[row[3], row[4], row[5]]]
            # Building the Temp_Dict1:
            # Try to append the list with the values for the key: row[3] = ToNodeID
            try:
                temp_dict_1[row[3]].append(row[2])
            # and if you cannot find it, create the key and assign the first element of the list as value
            except:
                temp_dict_1[row[3]] = [row[2]]
            if row[7] == 1:
                try:
                    temp_dict_0[row[3]].append([row[2], row[8], row[5]])
                except:
                    temp_dict_0[row[3]] = [[row[2], row[8], row[5]]]

                try:
                    temp_dict_1[row[2]].append(row[3])
                except:
                    temp_dict_1[row[2]] = [row[3]]

        return [temp_dict_0, temp_dict_1]

    def build_dictionary(self, dict_1, list_0):
        """ This method builds the adjacency dictionary
        @Param dict is the dictionary with the personal data of each node (visibility and class)
        @Param list is a list with the dictionaries tha hold the connectivity of each node in relation to the others
        @Return is the adjacency dictionary """

        # We need a list with all the IDs of the nodes
        # Get the rows of the table
        rows = self.get_rows_of_table("SELECT * FROM dbo."+self.nodes)
        # First lets create an empty dictionary
        adjacency_dictionary = {}
        # For each row of our NODES table
        # Each row[1] is the key-Node to our dictionaries
        for row in rows:
            try:
                # Checking if the Node does not connect to another node
                if row[1] not in list_0[0]:
                    # Checking if you cannot travel to our node from another node
                    if row[1] not in list_0[1]:
                        adjacency_dictionary[row[1]] = [dict_1[row[1]], [[], []]]
                    else:
                        adjacency_dictionary[row[1]] = [dict_1[row[1]], [[], list_0[1][row[1]]]]
                # Checking if you cannot traver to our node from another node
                elif row[1] not in list_0[1]:
                    # Checking if the Node does not connect to another node
                    if row[1] not in list_0[0]:
                        adjacency_dictionary[row[1]] = [dict_1[row[1]], [[], []]]
                    else:
                        adjacency_dictionary[row[1]] = [dict_1[row[1]], [list_0[0][row[1]], []]]
                else:
                    adjacency_dictionary[row[1]] = [dict_1[row[1]], [list_0[0][row[1]], list_0[1][row[1]]]]
            except:
                pass
        return adjacency_dictionary

    def print_dictionary(self, dict2):
        """This method takes a dictionary and prints it in a pretty way
        @Param dict is the dictionary """

        for keys, values in dict2.items():
            if values[0][2] != 5:
                k = PrettyTable([keys])
                k.add_row(["----->"])
                print k
                t = PrettyTable(['Visiblity', 'Class', 'Junction'])
                t.add_row(values[0])
                f = PrettyTable(['ToNodeID', 'StartCost', 'TravCost'])
                for part in values[1][0]:
                    f.add_row(part)
                c = PrettyTable(['FromNodeID'])
                for part in values[1][1]:
                    c.add_row([part])
                print t
                print f
                print c
                print ""
                print ""


def main():
    """ main class here."""
    # Create a connection to the database and the desired tables
    connection = Connect("NODES", "LINKS")
    # Create the adjacency Dictionary
    lis = Conversion(connection.nodes, connection.links, connection.cnxn)
    print lis.list_of_nodes_to_remove
    print lis.dictionary_of_personal_data
    """print lis.test
    print lis.test_1
    print"====="
    print lis.TEST
    print lis.FINAL"""
if __name__ == '__main__':
    main()
